class GeoJSONCache{constructor(){this.dbName="GeoJSONCache",this.version=105,this.storeName="geojson",this.db=null,this.compressionSupported="undefined"!=typeof CompressionStream}async init(){if(!this.db)return new Promise(((resolve,reject)=>{const request=indexedDB.open(this.dbName,this.version);request.onerror=()=>reject(request.error),request.onsuccess=()=>{this.db=request.result,resolve()},request.onupgradeneeded=event=>{const db=event.target.result;db.objectStoreNames.contains(this.storeName)&&db.deleteObjectStore(this.storeName),db.createObjectStore(this.storeName,{keyPath:"url"})}}))}async get(url){return await this.init(),new Promise((resolve=>{const request=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).get(url);request.onsuccess=()=>{const result=request.result;result&&Date.now()-result.timestamp<6048e5?result.compressed&&this.compressionSupported?this.decompressData(result.data).then(resolve).catch((()=>resolve(null))):resolve(result.data):resolve(null)},request.onerror=()=>resolve(null)}))}async set(url,data){await this.init();const store=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName);let storeData=data,compressed=!1;if(this.compressionSupported&&"object"==typeof data)try{storeData=await this.compressData(JSON.stringify(data)),compressed=!0}catch(error){console.warn("indexedDB compression failed",error),storeData=data}store.put({url:url,data:storeData,compressed:compressed,timestamp:Date.now()})}async compressData(text){const stream=new CompressionStream("gzip"),writer=stream.writable.getWriter(),reader=stream.readable.getReader();writer.write((new TextEncoder).encode(text)),writer.close();const chunks=[];let done=!1;for(;!done;){const{value:value,done:readerDone}=await reader.read();done=readerDone,value&&chunks.push(value)}return new Uint8Array(chunks.reduce(((acc,chunk)=>[...acc,...chunk]),[]))}async decompressData(compressedData){const stream=new DecompressionStream("gzip"),writer=stream.writable.getWriter(),reader=stream.readable.getReader();writer.write(compressedData),writer.close();const chunks=[];let done=!1;for(;!done;){const{value:value,done:readerDone}=await reader.read();done=readerDone,value&&chunks.push(value)}const decompressed=new Uint8Array(chunks.reduce(((acc,chunk)=>[...acc,...chunk]),[])),text=(new TextDecoder).decode(decompressed);return JSON.parse(text)}}class SearchControl{constructor(){this._container=null}onAdd(map){this._map=map,this._container=document.createElement("div"),this._container.className="maplibregl-ctrl maplibregl-ctrl-group",this._container.id="search-container",this._container.title="Search boundaries";const searchInput=document.createElement("input");return searchInput.id="search",searchInput.placeholder="",searchInput.autocomplete="off",this._container.appendChild(searchInput),this._container}onRemove(){this._container.parentNode.removeChild(this._container),this._map=void 0}}class LoadingManager{constructor(){this.current=0,this.total=0,this.element=this.createUI()}createUI(){const overlay=document.createElement("div");return overlay.id="loading-overlay",overlay.innerHTML='\n            <div class="loading-content">\n                <div class="loading-spinner"></div>\n                <div class="loading-header">Loading Map...</div>\n                <div class="loading-text">Initializing map</div>\n                <div class="progress-bar">\n                    <div class="progress-fill"></div>\n                </div>\n            </div>\n        ',document.body.appendChild(overlay),overlay}setTotal(total){this.total=total,this.current=0}step(message){this.current++;const progress=this.current/this.total*100,fill=this.element.querySelector(".progress-fill"),text=this.element.querySelector(".loading-text");fill&&(fill.style.width=`${progress}%`),text&&(text.textContent=message)}hide(){this.element&&(this.element.style.opacity="0",setTimeout((()=>this.element.remove()),300))}}class FeatureHighlighter{constructor(map){this.map=map,this.currentHighlight=null}highlight(feature,type="subdistrict"){this.clear();const id=`highlight-${Date.now()}`,colors={district:{fill:"#ff6b35",stroke:"#ff4500"},subdistrict:{fill:"#4ecdc4",stroke:"#26a69a"}},color=colors[type]||colors.subdistrict;this.map.addSource(id,{type:"geojson",data:{type:"FeatureCollection",features:[feature]},maxzoom:12,tolerance:.4,buffer:128}),this.map.addLayer({id:`${id}-fill`,type:"fill",source:id,paint:{"fill-color":color.fill,"fill-opacity":.6}}),this.map.addLayer({id:`${id}-stroke`,type:"line",source:id,paint:{"line-color":color.stroke,"line-width":3}}),this.currentHighlight=id,setTimeout((()=>this.clear()),3e3)}clear(){if(this.currentHighlight){const id=this.currentHighlight;this.map.getLayer(`${id}-fill`)&&this.map.removeLayer(`${id}-fill`),this.map.getLayer(`${id}-stroke`)&&this.map.removeLayer(`${id}-stroke`),this.map.getSource(id)&&this.map.removeSource(id),this.currentHighlight=null}}}class SearchIndex{constructor(){this.items=[],this.fuse=null,this.isReady=!1,this.lastQuery="",this.lastResults=[]}addItem(item){this.items.push(item),this.fuse=null,this.isReady=!1}addItems(items){this.items.push(...items),this.fuse=null,this.isReady=!1}async initializeFuse(){if(!this.fuse){if("undefined"==typeof Fuse)throw new Error("Fuse.js not loaded");this.fuse=new Fuse(this.items,{keys:[{name:"name",weight:.6,threshold:.4,distance:100},{name:"code",weight:.3,threshold:.1,distance:10},{name:"pinyin",weight:.1,threshold:.3,distance:50}],includeScore:!0,includeMatches:!0,ignoreLocation:!0,findAllMatches:!0,minMatchCharLength:1,shouldSort:!0,threshold:.4,distance:100}),this.isReady=!0}}search(query,limit=10){if(!this.isReady||!this.fuse)return[];if(query===this.lastQuery&&this.lastResults.length>0)return this.lastResults.slice(0,limit);const isNumericQuery=/^\d+$/.test(query);let results=this.fuse.search(query).slice(0,limit);return isNumericQuery&&(results=results.filter((result=>!(result.matches&&result.matches.some((m=>"code"===m.key)))||result.item.code.startsWith(query)))),this.lastQuery=query,this.lastResults=results,results}}class MapApp{constructor(){this.cache=new GeoJSONCache,this.loader=new LoadingManager,this.map=null,this.config=null,this.highlighter=null,this.searchIndex=new SearchIndex,this.searchInitialized=!1,this.compressionSupported=this.checkCompressionSupport(),this.markingCache=null,this.markingManager=null,this.markingControl=null,this.loadingState={districts:!1,subdistricts:!1,specialLayers:!1,labels:!1,search:!1,marking:!1}}checkCompressionSupport(){return"undefined"!=typeof DecompressionStream}async fetchJSON(url,options={}){const{enableCompression:enableCompression=!0,retries:retries=3}=options;for(let attempt=1;attempt<=retries;attempt++)try{let data=await this.cache.get(url);if(data)return data;if(enableCompression&&this.compressionSupported&&(url.includes(".geojson")||url.includes("/boundaries/")))try{const gzipUrl=url+".gz",response=await fetch(gzipUrl);if(response.ok){const stream=response.body.pipeThrough(new DecompressionStream("gzip")),decompressedResponse=new Response(stream);data=await decompressedResponse.json()}}catch(error){console.log(`Compressed fetch failed for ${url}, attempt ${attempt}:`,error)}if(!data){const response=await fetch(url);if(!response.ok)throw new Error(`HTTP ${response.status}: ${response.statusText}`);data=await response.json()}return await this.cache.set(url,data),data}catch(error){if(console.error(`Fetch attempt ${attempt} failed for ${url}:`,error),attempt===retries)throw new Error(`Failed to fetch ${url} after ${retries} attempts: ${error.message}`);await new Promise((resolve=>setTimeout(resolve,1e3*Math.pow(2,attempt))))}}async init(){try{this.loader.setTotal(8);const[config,style]=await Promise.all([this.fetchJSON("./src/boundaries/index.json",{enableCompression:!1}),this.fetchJSON("./src/schema/basic_minlabel.json",{enableCompression:!1})]);this.config=config,this.map=new maplibregl.Map({container:"map",style:style,zoom:10,pitchWithRotate:!1}),this.highlighter=new FeatureHighlighter(this.map),this.setupMapBounds(),this.setupMapControls(),this.loader.step("Map initializing"),this.map.on("load",(async()=>{await this.loadAllLayersParallel(),await this.setupSearch(),await this.setupMarkingSystem(),this.setupPopups(),this.loader.step("Complete!"),setTimeout((()=>this.loader.hide()),500)}))}catch(error){console.error("Failed to initialize:",error),this.loader.hide()}}setupMapControls(){this.map.addControl(new maplibregl.NavigationControl,"top-left"),this.map.addControl(new maplibregl.GeolocateControl({positionOptions:{enableHighAccuracy:!0},trackUserLocation:!0,showUserHeading:!0}),"top-left"),this.map.addControl(new SearchControl,"top-right")}async setupMarkingSystem(){try{this.loader.step("Initializing marking system"),await import("./marking-system.js"),this.markingCache=new MarkingCache,this.markingManager=new MarkingManager(this.map,this.markingCache),this.markingManager.setSearchIndex(this.searchIndex.items),await this.markingManager.init(),this.markingManager.applyAllFeatureStates(),this.markingManager.updatePaintProperties(),this.markingControl=new MarkingControl(this.markingManager,this.searchIndex.items),this.map.addControl(this.markingControl,"top-right")}catch(error){console.error("Failed to setup marking system:",error),this.loader.step("Marking system unavailable")}}setupMapBounds(){const bounds=[[115.41686,39.4415],[117.50904,41.05923]];this.map.fitBounds(bounds,{padding:40});const[sw,ne]=bounds,lngPad=.6*(ne[0]-sw[0]),latPad=.6*(ne[1]-sw[1]),maxBounds=[[sw[0]-lngPad,sw[1]-latPad],[ne[0]+lngPad,ne[1]+latPad]];this.map.setMaxBounds(maxBounds)}async loadAllLayersParallel(){try{const layerOperations=[];this.config.districtOutlines?.length&&layerOperations.push({type:"districts",operation:()=>this.loadDistrictsParallel()}),this.config.subdistrictLayers?.length&&layerOperations.push({type:"subdistricts",operation:()=>this.loadSubdistrictsParallel()}),this.config.specialLayers?.length&&layerOperations.push({type:"special",operation:()=>this.loadSpecialLayersParallel()}),this.config.cityOutline&&layerOperations.push({type:"city",operation:()=>this.addLayer("city-outline",this.config.cityOutline,"cityOutline")}),await this.executeWithConcurrencyLimit(layerOperations,3),this.loader.step("Adding labels"),await this.addLabelsParallel()}catch(error){throw console.error("Failed to load layers in parallel:",error),error}}async executeWithConcurrencyLimit(operations,limit=3){const results=[],executing=[];for(const op of operations){const promise=op.operation().then((result=>(executing.splice(executing.indexOf(promise),1),this.loader.step(`Loading ${op.type}`),result)));results.push(promise),executing.push(promise),executing.length>=limit&&await Promise.race(executing)}return Promise.all(results)}async loadDistrictsParallel(){const districtPromises=this.config.districtOutlines.map((file=>this.loadAndProcessDistrictData(file))),districtDataArray=await Promise.all(districtPromises);for(const{name:name,data:data,file:file}of districtDataArray)await this.addDistrictLayerToMap(name,data,file);this.loadingState.districts=!0}async loadAndProcessDistrictData(file){const name=file.split("/").pop().replace(".geojson",""),data=await this.fetchJSON(file),searchItems=[];return data.features.forEach((feature=>{const props=feature.properties||{};if(props.Name){let featureId=this.generateFeatureId(props,1e5);searchItems.push({name:props.Name,code:String(props.code||""),pinyin:props.pinyin||"",type:"district",feature:feature,featureId:featureId,sourceId:`${name}-outline`})}})),this.searchIndex.addItems(searchItems),{name:name,data:data,file:file}}async addDistrictLayerToMap(name,data,file){const id=`${name}-outline`,style=this.config.styles.districtOutline;this.map.addSource(id,{type:"geojson",data:data,maxzoom:12,tolerance:.4,buffer:128}),this.map.addLayer({id:id,type:style.type,source:id,paint:style.paint,layout:style.layout||{}})}async loadSubdistrictsParallel(){const subdistrictPromises=this.config.subdistrictLayers.map((file=>this.loadAndProcessSubdistrictData(file))),subdistrictDataArray=await Promise.all(subdistrictPromises);for(const{name:name,data:data}of subdistrictDataArray)await this.addSubdistrictLayerToMap(name,data);this.loadingState.subdistricts=!0}async loadAndProcessSubdistrictData(file){const name=file.split("/").pop().replace(".geojson",""),data=await this.fetchJSON(file),searchItems=[];return data.features.forEach(((feature,index)=>{const props=feature.properties||{};if(props.Name){let featureId=this.generateFeatureId(props);feature.id=featureId,searchItems.push({name:props.Name,code:String(props.code||""),pinyin:props.pinyin||"",type:"subdistrict",feature:feature,featureId:featureId,sourceId:`${name}-source`})}})),this.searchIndex.addItems(searchItems),{name:name,data:data}}async addSubdistrictLayerToMap(name,data){this.map.addSource(`${name}-source`,{type:"geojson",data:data,maxzoom:12,tolerance:.4,buffer:128}),this.map.addLayer({id:`${name}-fill`,type:"fill",source:`${name}-source`,paint:{"fill-color":["case",["boolean",["feature-state","marked"],!1],"#1e56e4",["boolean",["feature-state","unmarked"],!1],"#a34b4b",["match",["get","color_id"],1,"#e41e32",2,"#ff782a",3,"#e2cf04",4,"#98c217",5,"#3f64ce",6,"#7e2b8e","#cccccc"]],"fill-opacity":["case",["boolean",["feature-state","marked"],!1],.8,["boolean",["feature-state","unmarked"],!1],.2,.2]}}),this.map.addLayer({id:`${name}-line`,type:"line",source:`${name}-source`,paint:this.config.styles.subdistrictLine.paint})}async loadSpecialLayersParallel(){const specialPromises=this.config.specialLayers.map((special=>{const id=special.file.split("/").pop().replace(".geojson","");return this.addLayer(id,special.file,special.styleRef)}));await Promise.all(specialPromises),this.loadingState.special=!0}async addLabelsParallel(){const labelPromises=[];this.config.subdistrictLayers&&labelPromises.push(...this.config.subdistrictLayers.map((file=>this.addLabelLayer(file,"subdistrict")))),this.config.districtOutlines&&labelPromises.push(...this.config.districtOutlines.map((file=>this.addLabelLayer(file,"district")))),await Promise.all(labelPromises),this.loadingState.labels=!0}generateFeatureId(props,offset=0){if("string"==typeof props.code&&/^\d+$/.test(props.code))return parseInt(props.code,10)+offset;if("number"==typeof props.code&&Number.isInteger(props.code))return props.code+offset;{let hash=0;const nameStr=props.Name||"unknown";for(let i=0;i<nameStr.length;i++)hash=(hash<<5)-hash+nameStr.charCodeAt(i),hash|=0;return Math.abs(hash)+offset}}async addLayer(id,file,styleRef){const data=await this.fetchJSON(file),style=this.config.styles[styleRef];this.map.addSource(id,{type:"geojson",data:data,maxzoom:12,tolerance:.4,buffer:128}),this.map.addLayer({id:id,type:style.type,source:id,paint:style.paint,layout:style.layout||{}})}async addLabelLayer(file,type){const name=file.split("/").pop().replace(".geojson",""),data=await this.fetchJSON(file),defaults=this.config.labelLayerDefaults[type],labelFeatures=data.features.map((feature=>{const props=feature.properties||{},labelPoint=props.labelPoint;return labelPoint&&Array.isArray(labelPoint)&&2===labelPoint.length?{type:"Feature",properties:{Name:props.Name},geometry:{type:"Point",coordinates:[labelPoint[1],labelPoint[0]]}}:null})).filter((f=>null!==f));if(labelFeatures.length>0){const sourceId=`${name}-labels`;this.map.addSource(sourceId,{type:"geojson",data:{type:"FeatureCollection",features:labelFeatures},maxzoom:12,tolerance:.4,buffer:128}),this.map.addLayer({id:sourceId,type:"symbol",source:sourceId,minzoom:defaults.minzoom||("district"===type?8:10),maxzoom:defaults.maxzoom||("district"===type?12:22),layout:defaults.layout||{"text-field":["get","Name"]},paint:defaults.paint||{}})}}createSearchItem(item,matches=[]){const li=document.createElement("li"),typeLabel="district"===item.type?"区":"街道/乡镇",applyHighlights=(text,fieldMatches)=>{if(!fieldMatches||0===fieldMatches.length)return text;let highlightedText=text;const highlights=[];return fieldMatches.forEach((match=>{match.indices.forEach((([start,end])=>{highlights.push({start:start,end:end})}))})),highlights.sort(((a,b)=>b.start-a.start)),highlights.forEach((({start:start,end:end})=>{const before=highlightedText.substring(0,start),highlighted=highlightedText.substring(start,end+1),after=highlightedText.substring(end+1);highlightedText=before+"<mark>"+highlighted+"</mark>"+after})),highlightedText},nameMatches=matches.filter((m=>"name"===m.key)),codeMatches=matches.filter((m=>"code"===m.key)),highlightedName=applyHighlights(item.name,nameMatches),highlightedCode=applyHighlights(item.code,codeMatches);return li.innerHTML=`\n            <div style="display: flex; justify-content: space-between; align-items: center;">\n                <span>${highlightedName}</span>\n                <span style="font-size: 0.8em; color: #666;">${typeLabel}</span>\n            </div>\n            <div><span style="font-size: 0.8em; color: #888;">${highlightedCode}</span></div>\n        `,li}async setupSearch(){try{await this.searchIndex.initializeFuse();const searchInput=document.getElementById("search");if(!searchInput)return;const SEARCH_PLACEHOLDER="Search boundaries...";function expandSearch(){searchInput.classList.add("expanded"),searchInput.setAttribute("placeholder",SEARCH_PLACEHOLDER)}function collapseSearch(){searchInput.classList.remove("expanded"),searchInput.setAttribute("placeholder","")}searchInput.addEventListener("focus",expandSearch),searchInput.addEventListener("blur",(function(){searchInput.value||collapseSearch()})),searchInput.addEventListener("click",expandSearch),collapseSearch();const awesomplete=new Awesomplete(searchInput,{minChars:1,maxItems:10,autoFirst:!0,filter:()=>!0,item:(text,input)=>{const data=JSON.parse(text.value);return this.createSearchItem(data.item,data.matches)}});let searchTimeout;searchInput.addEventListener("input",(e=>{const query=e.target.value.trim();clearTimeout(searchTimeout),0!==query.length?searchTimeout=setTimeout((()=>{const results=this.searchIndex.search(query,10);awesomplete.list=results.map((result=>({label:this.formatResult(result.item),value:JSON.stringify({item:result.item,matches:result.matches||[]})})))}),100):awesomplete.list=[]})),searchInput.addEventListener("awesomplete-selectcomplete",(e=>{const item=JSON.parse(e.text.value).item;searchInput.value=item.name,this.fitToFeature(item.feature),this.highlighter.highlight(item.feature,item.type)})),this.searchInitialized=!0,this.loader.step("Search ready"),console.log(`Search index found ${this.searchIndex.items.length} items`)}catch(error){console.error("Failed to setup search:",error),this.loader.step("Search unavailable")}}formatResult(item){const typeLabel="district"===item.type?"区":"街道/乡镇";return`${item.name} - ${typeLabel}`}fitToFeature(feature){if(!feature.geometry)return;const coords=[],extractCoords=c=>{"number"==typeof c[0]?coords.push(c):c.forEach(extractCoords)};if(extractCoords(feature.geometry.coordinates),0===coords.length)return;const bounds=coords.reduce(((bounds,coord)=>bounds.extend(coord)),new maplibregl.LngLatBounds(coords[0],coords[0]));this.map.fitBounds(bounds,{padding:100,duration:1200,essential:!0,maxZoom:14,easing:x=>x<.5?(1-Math.sqrt(1-Math.pow(2*x,2)))/2:(Math.sqrt(1-Math.pow(-2*x+2,2))+1)/2})}setupPopups(){const popup=new maplibregl.Popup({closeButton:!0,closeOnClick:!1});this.map.on("click",(e=>{const clickPoint=[e.lngLat.lng,e.lngLat.lat],subdistrictFeatures=this.map.queryRenderedFeatures(e.point).filter((f=>f.source&&f.source.endsWith("-source")&&f.layer.id.endsWith("-fill")));if(subdistrictFeatures.length>0){const correctFeature=this.findCorrectFeatureForPoint(clickPoint,subdistrictFeatures);correctFeature&&this.handleSubdistrictClick(correctFeature,e.lngLat,popup)}})),this.map.on("mouseenter",(e=>{this.map.queryRenderedFeatures(e.point).some((f=>f.source&&f.source.endsWith("-source")&&f.layer.id.endsWith("-fill")))&&(this.map.getCanvas().style.cursor="pointer")})),this.map.on("mouseleave",(()=>{this.map.getCanvas().style.cursor=""}))}findCorrectFeatureForPoint(point,candidates){const exactMatches=[];for(const candidate of candidates){const name=candidate.properties.Name,originalFeature=this.getOriginalFeatureByName(name);originalFeature&&this.isPointInFeature(point,originalFeature)&&exactMatches.push({feature:candidate,original:originalFeature})}if(0===exactMatches.length)return candidates[0];if(1===exactMatches.length)return exactMatches[0].feature;let bestMatch=exactMatches[0],smallestArea=this.calculatePolygonArea(bestMatch.original.geometry);for(let i=1;i<exactMatches.length;i++){const area=this.calculatePolygonArea(exactMatches[i].original.geometry);area<smallestArea&&(smallestArea=area,bestMatch=exactMatches[i])}return bestMatch.feature}getOriginalFeatureByName(name){const searchItem=this.searchIndex.items.find((item=>item.name===name&&"subdistrict"===item.type));return searchItem?searchItem.feature:null}isPointInFeature(point,feature){const geometry=feature.geometry;return"Polygon"===geometry.type?this.isPointInPolygon(point,geometry.coordinates):"MultiPolygon"===geometry.type&&geometry.coordinates.some((polygon=>this.isPointInPolygon(point,polygon)))}isPointInPolygon(point,coordinates){const[x,y]=point,exteriorRing=coordinates[0];if(!this.pointInRing(x,y,exteriorRing))return!1;for(let i=1;i<coordinates.length;i++){const hole=coordinates[i];if(this.pointInRing(x,y,hole))return!1}return!0}pointInRing(x,y,ring){let inside=!1;for(let i=0,j=ring.length-1;i<ring.length;j=i++){const xi=ring[i][0],yi=ring[i][1],xj=ring[j][0],yj=ring[j][1];yi>y!=yj>y&&x<(xj-xi)*(y-yi)/(yj-yi)+xi&&(inside=!inside)}return inside}calculatePolygonArea(geometry){return"Polygon"===geometry.type?this.ringArea(geometry.coordinates[0]):"MultiPolygon"===geometry.type?geometry.coordinates.reduce(((total,polygon)=>total+this.ringArea(polygon[0])),0):0}ringArea(ring){let area=0;for(let i=0;i<ring.length-1;i++)area+=ring[i][0]*ring[i+1][1]-ring[i+1][0]*ring[i][1];return Math.abs(area)/2}handleSubdistrictClick(feature,lngLat,popup){const name=feature.properties.Name||"Unknown",searchItem=this.searchIndex.items.find((item=>item.name===name&&"subdistrict"===item.type));let markButtonHtml="";if(this.markingManager&&searchItem){const isMarked=this.markingManager.isMarked(searchItem);markButtonHtml=`\n            <button class="popup-mark-btn ${isMarked?"marked":""}" \n                    onclick="window.mapApp.toggleFeatureMarking('${name}', 'subdistrict', ${!isMarked})">\n                ${isMarked?"Unmark":"Mark"} Sub-district\n            </button>\n        `}popup.setLngLat(lngLat).setHTML(`\n            <div style="font-weight: 500;">${name}</div>\n            ${markButtonHtml}\n        `).addTo(this.map)}async toggleFeatureMarking(featureName,type,marked){if(!this.markingManager)return;await this.markingManager.markFeatureByName(featureName,type,marked),this.markingControl&&this.markingControl.isOpen&&this.markingControl.updatePanel();const popups=document.getElementsByClassName("maplibregl-popup");popups.length>0&&popups[0].remove()}}window.mapApp=new MapApp,window.mapApp.init();